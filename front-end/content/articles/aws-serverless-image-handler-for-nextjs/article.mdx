---
title: Remote image optimization API for Next.js static websites
slug: aws-serverless-image-handler-for-nextjs
date: 2024-08-25
draft: true
description: Remote image optimization API for Next.js static websites
thumbnail: /articles/feature-branches-npm/feature-branches-for-NPM-modules.png
tags:
    - AWS
    - Next.js
keywords:
    - AWS
    - serverless image handler
    - image optimization service
---

# Remote image optimization API for Next.js static websites

## Can I have a static website with optimized images in Next.js?

Well... Next.js does not provide built-in support for image optimization in statically exported web apps. Unlike Gatsby.js, which processes and optimizes images during the build process, Next.js requires either pre-optimized local images or the use of a remote image optimization service. This limitation means that developers need to handle image optimization manually or rely on external services.

In this article I'll explain why I preferred to use a remote image optimization service for a Next.js static website and how I integrated it with the Serverless Image Handler from AWS Solutions.

## tl;dr Just show me the code!

> [GitHub repo](https://github.com/AlexeyPopovUA/nextjs-remote-images/)

> [Demo app](https://nextjs-remote-images.examples.oleksiipopov.com/)

> [Serverless Image Handler on AWS](https://aws.amazon.com/solutions/implementations/serverless-image-handler/)

## What happens in other frameworks?

Quick investigation shows that other popular frameworks like Gatsby.js and Svelte have different approaches to image optimization in **static websites**:

| Framework | Build Time Image Optimization Support                                                                                                                        | Image Optimization Service |
|-----------|--------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------|
| Gatsby.js | Plugins like [gatsby-plugin-image](https://www.gatsbyjs.com/plugins/gatsby-plugin-image/) and gatsby-transformer-sharp                                       | Optional                   |
| Next.js   | Custom tooling to generate pre-optimized images. For instance, [Next-Image-Export-Optimizer](https://github.com/Niels-IO/next-image-export-optimizer#readme) | Required                   |
| Svelte    | third-party plugins or preprocessors                                                                                                                         | Required                   |
| Astro     | [@astrojs/image integration](https://docs.astro.build/en/guides/images/)                                                                                     | Optional                   |

## Choosing the right approach

That problem made me to reconsider the convenient Gatsby solution as I had in previous projects. I needed to choose between using a remote image optimization service or pre-optimizing images locally during the build process. Both approaches have their pros and cons, depending on factors such as setup complexity, build time, flexibility, performance, storage requirements, cost, maintenance, and other considerations. Here's a comparison of the two approaches:

| Feature/Aspect           | Remote Images (Image Optimization API)                                                                  | Locally Exported Pre-Optimized Images (Build Time)                                    |
|--------------------------|---------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------|
| **Setup Complexity**     | Requires setting up an external service or API, configuring loaders, and handling API keys and security | Requires configuring build tools to generate multiple image sizes                     |
| **Build Time**           | Faster, as images are not processed during the build                                                    | Slower, as images are processed and optimized during the build                        |
| **Flexibility**          | High, can dynamically request different sizes and formats based on device and network conditions        | Limited to the sizes and formats generated during the build                           |
| **Loading Speed**        | Potentially better, as images can be optimized on-the-fly based on the user's device and network        | Dependent on the pre-generated sizes; may not be as optimized for all scenarios       |
| **Storage Requirements** | Potentially lower, as images are stored and served by the external service                              | Higher, as multiple sizes of each image need to be stored locally                     |
| **Cost**                 | May incur costs based on usage, API calls, and data transfer                                            | One-time cost during build; also, CDN traffic costs                                   |
| **Maintenance**          | Requires maintaining API integration and handling potential changes in the external service             | Requires maintaining build scripts and ensuring all necessary sizes are generated     |
| **CDN Integration**      | Can be integrated with CDN for faster delivery                                                          | Uses the same CDN as other assets, but requires uploading of all pre-generated images |
| **Image Quality**        | Can dynamically adjust quality based on user conditions                                                 | Fixed quality based on build-time settings                                            |
| **Fallback Handling**    | Can provide fallbacks dynamically if the API fails                                                      | Fallbacks need to be pre-generated and included during the build                      |
| **Initial Page Load**    | May be slower initially due to API calls                                                                | Faster initial load as images are served directly from the local storage or CDN       |
| **Caching**              | Can leverage API and CDN caching strategies                                                             | Can leverage CDN caching, but requires proper cache invalidation strategies           |

Looking at the comparison, I decided to use a remote image optimization service for my Next.js website. This approach offers more flexibility, faster build times, lower storage requirements, and potentially better image optimization based on user conditions.

Next problem is to find a suitable image optimization service. I chose the Serverless Image Handler from AWS Solutions, which offers a range of image optimization and modification techniques, including resizing, cropping, and automatic serving of WEBP, PNG, and JPEG formats. The service is based on the Sharp library and can be deployed to a personal AWS account using a CloudFormation template.

## Architecture

The Serverless Image Handler service does not support assigning a custom domain name, setting up hosting cache and viewer policies, retrieving image metadata information, or providing convenient image maintenance. To address these limitations, I needed to create a CloudFront distribution with caching policies, Cache-Control response headers, and Content Security Policy, and delegate all requests to the original distribution.

Original architecture of the Serverless Image Handler from AWS Solutions:

![Architecture](/articles/nextjs-images/architecture.png "Architecture (Â© AWS Solutions)")

When I added the CloudFront distribution, the architecture looked like this:

@TODO add the architecture diagram

## How to integrate the Serverless Image Handler with Next.js

In case if you need a completely static website, mostly rendered on build time and partially on a client, then you typically use the ```output: 'export'``` option of ```next.config.mjs``` configuration file. See [the details here](https://nextjs.org/docs/app/building-your-application/deploying/static-exports). This mode has [restrictions](https://nextjs.org/docs/app/building-your-application/deploying/static-exports#unsupported-features), one of which is [unsupported image optimization](https://nextjs.org/docs/app/building-your-application/deploying/static-exports#image-optimization). So, in our case, images could be loaded with a custom "loader", which "knows" how to get a correct URL of an image, based on its size, quality and path. 

The service from AWS Solutions provides a URL-based API to request images with specific transformations. For example, to request an image, you use the following URL:

```html
<img src="https://<your-domain>/<base64-cfg>" alt="Image description">
```

where `<your-domain>` is the domain of the Serverless Image Handler service, and `<base64-cfg>` is a base64-encoded JSON object containing the image transformation parameters. For example:

```json
{
  "bucket": "my-bucket",
  "key": "path/to/my-image.jpg",
  "edits": {
    "webp": {
      "quality": 75
    },
    "png": {
      "quality": 75
    },
    "resize": {
      "width": 300,
      "height": 200,
      "fit": "cover"
    }
  }
}
```

