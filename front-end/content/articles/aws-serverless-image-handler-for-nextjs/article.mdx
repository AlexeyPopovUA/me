---
title: Remote image optimization API for Next.js static websites
slug: aws-serverless-image-handler-for-nextjs
date: 2024-08-25
draft: true
description: Remote image optimization API for Next.js static websites
thumbnail: /articles/feature-branches-npm/feature-branches-for-NPM-modules.png
tags:
    - AWS
    - Next.js
keywords:
    - AWS
    - serverless image handler
    - image optimization service
---

# Remote image optimization API for Next.js static websites

## Can I have a static website with optimized images in Next.js?

Well... ~~not so fast~~ Next.js does not provide built-in support for image optimization in statically exported web apps. Unlike Gatsby.js, which processes and optimizes images during the build process, Next.js requires either pre-optimized local images or the use of a remote image optimization service. This limitation means that developers need to handle image optimization manually or rely on external services.

In this article I'll explain why I preferred to use a remote image optimization service for a Next.js static website and how I integrated it with the Serverless Image Handler from AWS Solutions.

## TL;DR

**Just give me the links!**

> [GitHub repo](https://github.com/AlexeyPopovUA/nextjs-remote-images/)

> [Demo app](https://nextjs-remote-images.examples.oleksiipopov.com/)

> [Serverless Image Handler on AWS](https://aws.amazon.com/solutions/implementations/serverless-image-handler/)

## What happens in other frameworks?

Quick investigation shows that other popular frameworks like Gatsby.js and Svelte have different approaches to image optimization in **static websites**:

| Framework     | Build Time Image Optimization Support                                                                                                                        | Image Optimization Service |
|---------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------|
| **Gatsby.js** | Plugins like [gatsby-plugin-image](https://www.gatsbyjs.com/plugins/gatsby-plugin-image/) and gatsby-transformer-sharp                                       | Optional                   |
| **Next.js**   | Custom tooling to generate pre-optimized images. For instance, [Next-Image-Export-Optimizer](https://github.com/Niels-IO/next-image-export-optimizer#readme) | Required                   |
| **Svelte**    | third-party plugins or preprocessors                                                                                                                         | Required                   |
| **Astro**     | [@astrojs/image integration](https://docs.astro.build/en/guides/images/)                                                                                     | Optional                   |

## Choosing the right approach

That problem made me to reconsider the convenient Gatsby solution as I had in previous projects. I needed to choose between using a remote image optimization service or pre-optimizing images locally during the build process. Both approaches have their pros and cons, depending on factors such as setup complexity, build time, flexibility, performance, storage requirements, cost, maintenance, and other considerations. Here's a comparison of the two approaches:

| Feature/Aspect           | Remote Images (Image Optimization API)                                                                  | Locally Exported Pre-Optimized Images (Build Time)                                    |
|--------------------------|---------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------|
| **Setup Complexity**     | Requires setting up an external service or API, configuring loaders, and handling API keys and security | Requires configuring build tools to generate multiple image sizes                     |
| **Build Time**           | Faster, as images are not processed during the build                                                    | Slower, as images are processed and optimized during the build                        |
| **Flexibility**          | High, can dynamically request different sizes and formats based on device and network conditions        | Limited to the sizes and formats generated during the build                           |
| **Loading Speed**        | Potentially better, as images can be optimized on-the-fly based on the user's device and network        | Dependent on the pre-generated sizes; may not be as optimized for all scenarios       |
| **Storage Requirements** | Potentially lower, as images are stored and served by the external service                              | Higher, as multiple sizes of each image need to be stored locally                     |
| **Cost**                 | May incur costs based on usage, API calls, and data transfer                                            | One-time cost during build; also, CDN traffic costs                                   |
| **Maintenance**          | Requires maintaining API integration and handling potential changes in the external service             | Requires maintaining build scripts and ensuring all necessary sizes are generated     |
| **CDN Integration**      | Can be integrated with CDN for faster delivery                                                          | Uses the same CDN as other assets, but requires uploading of all pre-generated images |
| **Image Quality**        | Can dynamically adjust quality based on user conditions                                                 | Fixed quality based on build-time settings                                            |
| **Fallback Handling**    | Can provide fallbacks dynamically if the API fails                                                      | Fallbacks need to be pre-generated and included during the build                      |
| **Initial Page Load**    | May be slower initially due to API calls                                                                | Faster initial load as images are served directly from the local storage or CDN       |
| **Caching**              | Can leverage API and CDN caching strategies                                                             | Can leverage CDN caching, but requires proper cache invalidation strategies           |

Looking at the comparison, I decided to use a remote image optimization service for my Next.js website. This approach offers more flexibility, faster build times, lower storage requirements, and potentially better image optimization based on user conditions.

## Serverless image handler from AWS Solutions

Next problem is to find a suitable image optimization service. I chose the Serverless Image Handler from AWS Solutions, which offers a range of image optimization and modification techniques, including resizing, cropping, and automatic serving of WEBP, PNG, and JPEG formats. The service is based on the Sharp library and can be deployed to a personal AWS account using a CloudFormation template.

| What it offers                                   | What is missing                           | What I added          |
|--------------------------------------------------|-------------------------------------------|-----------------------|
| Resizing                                         | Custom domain name                        | Custom domain name    |
| Cropping                                         | Hosting cache and viewer policies control | Hosting cache control |
| Filters                                          | Image metadata information retrieval      |                       |
| Automatic serving of WEBP, PNG, and JPEG formats | Convenient image maintenance              |                       |
| Demo app                                         |                                           |                       |
| etc.                                             |                                           |                       |

To address some of the limitations, I needed to create a CloudFront distribution with caching policies, Cache-Control response headers, and Content Security Policy, and delegate all requests to the original distribution.

Original architecture of the Serverless Image Handler from AWS Solutions:

![Original architecture](/articles/nextjs-images/serverless-image-handler-original.png "Original architecture (Â© AWS Solutions)")

There is also an optional demo app that lets you try out the Serverless Image Handler service with a sample image:

![Image handler demo app](/articles/nextjs-images/image-handler-demo.png "Image handler demo app")

Custom domain name, cache and viewer policies were the most important missing parts for me. For adding those, I've implemented a CloudFront distribution to delegate all requests to the original distribution.

When I added the CloudFront distribution, the architecture looked like this:

![Architecture with custom domain name](/articles/nextjs-images/serverless-image-handler-with-domain.png "Architecture with custom domain name")

Here is the [AWS-CDK](https://aws.amazon.com/cdk/) code snippet for the CloudFront distribution just to give you some implementation details:

```ts
export class ImageServiceProxyStack extends Stack {
  constructor(scope: Construct, id: string, props: StackProps) {
    super(scope, id, props);

    const project = configuration.COMMON.project;

    // Hosted zone provides you with a domain name
    const hostedZone = HostedZone.fromHostedZoneAttributes(this, `${project}-hosted-zone`, {
      hostedZoneId: configuration.HOSTING.hostedZoneID,
      zoneName: configuration.HOSTING.hostedZoneName
    });

    // Certifiacte is necessary to use HTTPS
    const certificate = new Certificate(this, `${project}-cert`, {
      domainName: configuration.HOSTING.imageProxyDomainName,
      validation: CertificateValidation.fromDns(hostedZone)
    });

    // Cache policy for the CloudFront distribution to control caching and excoding behavior
    const cachePolicy = new CachePolicy(this, `${project}-cache-policy`, {
      cachePolicyName: `${project}-proxy-cache-policy`,
      headerBehavior: CacheHeaderBehavior.allowList("Accept"),
      cookieBehavior: CacheCookieBehavior.none(),
      enableAcceptEncodingBrotli: true,
      enableAcceptEncodingGzip: true,
      minTtl: Duration.days(30),
      maxTtl: Duration.days(365),
      defaultTtl: Duration.days(100)
    });

    // CloudFront distribution to delegate all requests to the original distribution
    const distribution = new Distribution(this, `${project}-proxy-distribution`, {
      comment: `${project}-main image proxy distribution`,
      httpVersion: HttpVersion.HTTP2_AND_3,
      priceClass: PriceClass.PRICE_CLASS_ALL,
      certificate,
      enableIpv6: true,
      minimumProtocolVersion: SecurityPolicyProtocol.TLS_V1_2_2021,
      enableLogging: true,
      enabled: true,
      domainNames: [
        configuration.HOSTING.imageProxyDomainName
      ],
      defaultBehavior: {
        allowedMethods: AllowedMethods.ALLOW_GET_HEAD_OPTIONS,
        cachePolicy,
        cachedMethods: CachedMethods.CACHE_GET_HEAD_OPTIONS,
        compress: true,
        viewerProtocolPolicy: ViewerProtocolPolicy.REDIRECT_TO_HTTPS,
        origin: new HttpOrigin(configuration.HOSTING.imageProxyOriginDomain, {
          originShieldEnabled: true,
          protocolPolicy: OriginProtocolPolicy.HTTPS_ONLY
        })
      }
    });

    // Record sets to point the domain name to the CloudFront distribution (IPv4)
    new ARecord(this, `${project}-record-a`, {
      recordName: configuration.HOSTING.imageProxyDomainName,
      zone: hostedZone,
      target: RecordTarget.fromAlias(new CloudFrontTarget(distribution))
    });

    // Record sets to point the domain name to the CloudFront distribution (IPv6)
    new AaaaRecord(this, `${project}-record-4a`, {
      recordName: configuration.HOSTING.imageProxyDomainName,
      zone: hostedZone,
      target: RecordTarget.fromAlias(new CloudFrontTarget(distribution))
    });
  }
}
```

## How to integrate the Serverless Image Handler with Next.js

In case if you need a completely static website, mostly rendered on build time and partially on a client, then you typically use the ```output: 'export'``` option of ```next.config.mjs``` configuration file. See [the details here](https://nextjs.org/docs/app/building-your-application/deploying/static-exports). This mode has [restrictions](https://nextjs.org/docs/app/building-your-application/deploying/static-exports#unsupported-features), one of which is [unsupported image optimization](https://nextjs.org/docs/app/building-your-application/deploying/static-exports#image-optimization). So, in our case, images could be loaded with a custom "loader", which "knows" how to get a correct URL of an image, based on its size, quality and path. 

The service from AWS Solutions provides a URL-based API to request images with specific transformations. For example, to request an image, you use the following URL:

```html
<img src="https://<your-domain>/<base64-cfg>" alt="Image description">
```

where `<your-domain>` is the domain of the Serverless Image Handler service, and `<base64-cfg>` is a base64-encoded JSON object containing the image transformation parameters. For example:

```json
{
  "bucket": "my-bucket",
  "key": "path/to/my-image.jpg",
  "edits": {
    "webp": {
      "quality": 75
    },
    "png": {
      "quality": 75
    },
    "resize": {
      "width": 300,
      "height": 200,
      "fit": "cover"
    }
  }
}
```

## The Demo Application

In order to show the different implementations of images in a static Next.js app and AWS Serverless Image Handler, I have built [this demo app](https://nextjs-remote-images.examples.oleksiipopov.com/). It contains multiple examples of image optimization and loading techniques, including:

* Single responsive image (simple next/image component)
* Single responsive image with blur placeholder (next/image component with blurDataURL and placeholder="blur" attributes)
* Single responsive image with blur transition (animation on image load)
* Thumbnails with different "image fit" modes (next/image component with different `resize.fit` API configurations)
* Full Thumbnails with loading animation
* Cropped Thumbnails with loading animation

![/articles/nextjs-images/landing-page.png](/articles/nextjs-images/landing-page.png "Home page")

### Single responsive image

It is the simplest use case of next/image component. It loads an image with a specific size and quality. The image is resized based on the device's screen size and resolution.

> [Single responsive image demo](https://nextjs-remote-images.examples.oleksiipopov.com/examples/responsive-single-image/)

If you click on the video below, you will see how the loading of different image sizes happens (normal network):

<ArticleVideo src="/content/articles/aws-serverless-image-handler-for-nextjs/responsive-single-image-resizing.webm" poster="/articles/nextjs-images/responsive-single-image-resizing-v-frame.png"></ArticleVideo>

Pay a special attention at the visual loading process of a single responsive image in a non-ideal connectivity (3G network emulation):

<ArticleVideo src="/content/articles/aws-serverless-image-handler-for-nextjs/responsive-single-image.webm" poster="/articles/nextjs-images/responsive-single-image-v-frame.png"></ArticleVideo>

Image renders partially, which is not a good user experience. To improve it, we can use a blur placeholder.

### Single responsive image with blur placeholder

> [Single responsive image with blur placeholder](https://nextjs-remote-images.examples.oleksiipopov.com/examples/blurred-single-image/)

<ArticleVideo src="/content/articles/aws-serverless-image-handler-for-nextjs/single-responsive-image-with-blur.webm" poster="/articles/nextjs-images/single-responsive-image-with-blur-frame.png" type="video/webm"></ArticleVideo>

### Single responsive image with blur transition

> [Single responsive image with blur transition](https://nextjs-remote-images.examples.oleksiipopov.com/examples/blurred-animated-single-image/)

<ArticleVideo src="/content/articles/aws-serverless-image-handler-for-nextjs/single-responsive-image-blur-transition.webm" poster="/articles/nextjs-images/single-responsive-image-blur-transition-frame.png" type="video/webm"></ArticleVideo>

### Thumbnails with different "image fit" modes

> [Thumbnails with different "image fit" modes](https://nextjs-remote-images.examples.oleksiipopov.com/examples/thumbnail-image-fit/)

![Thumbnails with different 'image fit' modes](/articles/nextjs-images/fill-image-options-thumbnails.png "Thumbnails with different 'image fit' modes")

### Cropped Thumbnails with loading animation

> [Cropped Thumbnails with loading animation (scroll down)](https://nextjs-remote-images.examples.oleksiipopov.com/examples/animated-thumbnails/)

<ArticleVideo src="/content/articles/aws-serverless-image-handler-for-nextjs/cropped-thumbnails-loading.webm" type="video/webm" poster="/articles/nextjs-images/cropped-thumbnails-loading-frame.png"></ArticleVideo>

### Full Thumbnails with loading animation

> [Full Thumbnails with loading animation](https://nextjs-remote-images.examples.oleksiipopov.com/examples/animated-thumbnails/)

<ArticleVideo src="/content/articles/aws-serverless-image-handler-for-nextjs/full-image-thumbnails-loading.webm" poster="/articles/nextjs-images/full-image-thumbnails-loading-frame.png" type="video/webm"></ArticleVideo>

## What is necessary to improve

### Image dimensions retrieval

## Conclusion
