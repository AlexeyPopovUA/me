---
title: Remote image optimization API for Next.js static websites
slug: aws-serverless-image-handler-for-nextjs
date: 2024-08-25
draft: true
description: Remote image optimization API for Next.js static websites
thumbnail: /articles/feature-branches-npm/feature-branches-for-NPM-modules.png
tags:
    - AWS
    - Next.js
keywords:
    - AWS
    - serverless image handler
    - image optimization service
---

# Remote image optimization API for Next.js static websites

## Can I have a static website with optimized images in Next.js?

Well... Next.js does not provide built-in support for image optimization in statically exported web apps. Unlike Gatsby.js, which processes and optimizes images during the build process, Next.js requires either pre-optimized local images or the use of a remote image optimization service. This limitation means that developers need to handle image optimization manually or rely on external services.

In this article I'll explain why I preferred to use a remote image optimization service for a Next.js static website and how I integrated it with the Serverless Image Handler from AWS Solutions.

## tl;dr Just show me the code!

> [GitHub repo](https://github.com/AlexeyPopovUA/nextjs-remote-images/)

> [Demo app](https://nextjs-remote-images.examples.oleksiipopov.com/)


## What happens in other frameworks?

Quick investigation shows that other popular frameworks like Gatsby.js and Svelte have different approaches to image optimization in **static websites**:

| Framework | Build Time Image Optimization Support                                                                                                                        | Image Optimization Service |
|-----------|--------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------|
| Gatsby.js | Plugins like [gatsby-plugin-image](https://www.gatsbyjs.com/plugins/gatsby-plugin-image/) and gatsby-transformer-sharp                                       | Optional                   |
| Next.js   | Custom tooling to generate pre-optimized images. For instance, [Next-Image-Export-Optimizer](https://github.com/Niels-IO/next-image-export-optimizer#readme) | Required                   |
| Svelte    | third-party plugins or preprocessors                                                                                                                         | Required                   |
| Astro     | [@astrojs/image integration](https://docs.astro.build/en/guides/images/)                                                                                     | Optional                   |

## Choosing the right approach

That problem made me to reconsider the convenient Gatsby solution as I had in previous projects. I needed to choose between using a remote image optimization service or pre-optimizing images locally during the build process. Both approaches have their pros and cons, depending on factors such as setup complexity, build time, flexibility, performance, storage requirements, cost, maintenance, and other considerations. Here's a comparison of the two approaches:

| Feature/Aspect           | Remote Images (Image Optimization API)                                                                  | Locally Exported Pre-Optimized Images (Build Time)                                    |
|--------------------------|---------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------|
| **Setup Complexity**     | Requires setting up an external service or API, configuring loaders, and handling API keys and security | Requires configuring build tools to generate multiple image sizes                     |
| **Build Time**           | Faster, as images are not processed during the build                                                    | Slower, as images are processed and optimized during the build                        |
| **Flexibility**          | High, can dynamically request different sizes and formats based on device and network conditions        | Limited to the sizes and formats generated during the build                           |
| **Loading Speed**        | Potentially better, as images can be optimized on-the-fly based on the user's device and network        | Dependent on the pre-generated sizes; may not be as optimized for all scenarios       |
| **Storage Requirements** | Potentially lower, as images are stored and served by the external service                              | Higher, as multiple sizes of each image need to be stored locally                     |
| **Cost**                 | May incur costs based on usage, API calls, and data transfer                                            | One-time cost during build; also, CDN traffic costs                                   |
| **Maintenance**          | Requires maintaining API integration and handling potential changes in the external service             | Requires maintaining build scripts and ensuring all necessary sizes are generated     |
| **CDN Integration**      | Can be integrated with CDN for faster delivery                                                          | Uses the same CDN as other assets, but requires uploading of all pre-generated images |
| **Image Quality**        | Can dynamically adjust quality based on user conditions                                                 | Fixed quality based on build-time settings                                            |
| **Fallback Handling**    | Can provide fallbacks dynamically if the API fails                                                      | Fallbacks need to be pre-generated and included during the build                      |
| **Initial Page Load**    | May be slower initially due to API calls                                                                | Faster initial load as images are served directly from the local storage or CDN       |
| **Caching**              | Can leverage API and CDN caching strategies                                                             | Can leverage CDN caching, but requires proper cache invalidation strategies           |

## How

In case if you need a completely static website, mostly rendered on build time and partially on a client, then you typically use the ```output: 'export'``` option of ```next.config.mjs``` configuration file. See [the details here](https://nextjs.org/docs/app/building-your-application/deploying/static-exports). This mode has [restrictions](https://nextjs.org/docs/app/building-your-application/deploying/static-exports#unsupported-features), one of which is [unsupported image optimization](https://nextjs.org/docs/app/building-your-application/deploying/static-exports#image-optimization). Basically, either you use local pre-processed images or a remote optimization service. Images could be loaded with a custom "loader", which "knows" how to get a correct URL of an image, based on its size, quality and path. Obviously, maintaining multiple sizes of the same image locally in  a blog-like project is a nightmare. So, the remote optimization service is a way.

One of the cheapest image optimization solutions, that is already implemented by someone else, and could be completely controlled and [reviewed](https://github.com/aws-solutions/serverless-image-handler/tree/main) by a developer, is [Serverless Image Handler on AWS](https://aws.amazon.com/solutions/implementations/serverless-image-handler/), available in  [AWS Solutions Library](https://aws.amazon.com/solutions/). It offers different image optimization and modification techniques. Resizing, cropping and automatic serving of WEBP, PNG and JPEG formats - are just a few possibilities of the service. Only the [Sharp](https://sharp.pixelplumbing.com/) library is the limit. Also, this is an open code solution, one can deploy to the personal AWS account, using Cloud Formation template. Image resizing agent is a lambda, but not a permanently running Node.js server, that makes it extremely cheap in case of properly setup hosting caching policy.

Serverless Image Handler from AWS Solutions does not support assigning a custom domain name and set up many other things. It is basically an example of a solution, that is considered to be a good one. And it definitely is! So we need to apply a bit more effort and create own CloudFront distribution with Caching policy, Cache Control response headers and Content Security Policy and delegation of all request to the original distribution.

As a bonus point, we will add tiny blurry versions of images to HTML files, so we have smth rendered on the page immediately, while browser is busy with loading a proper image taken from an image ```srcset```.


## Architecture

![Architecture](/articles/nextjs-images/architecture.png "Architecture (Â© AWS Solutions)")

